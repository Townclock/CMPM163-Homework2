Shader "Custom/ReflectionBuzzProbe"
{
//https://gist.github.com/josephbk117/a43f5335cea9b3e12a44f196dc81f30f
	Properties
	{
		_MainTex ("Texture", 2D) = "" {}
		_Color ("Color", Color) = (0, 0, 0, 0)
		_Cube ("Cube", Cube) = ""{}
		_Roughness("Roughness", Range(0.0, 10.0)) = 0.0
	}
	SubShader
	{
		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
		    float3 normal : NORMAL;		
                float2 uv : TEXCOORD0;
		  };

			struct v2f
			{
				float4 vertex : SV_POSITION;
				float3 normalInWorldCoords : NORMAL;
				float3 vertexInWorldCoords : TEXCCORD1;
                float2 uv : TEXCOORD0;
			};

			uniform samplerCUBE _Cube;
			uniform float4 _Color;
			uniform float _Roughness;
			uniform sampler2D _MainTex;
			float4 _MainTex_ST;
			uniform float2	 _MainTex_TexelSize;
			
			v2f vert (appdata v)
			{
				v2f o;
				
				o.vertexInWorldCoords = mul(unity_ObjectToWorld, v.vertex);
				
				o.normalInWorldCoords = UnityObjectToWorldNormal(v.normal);
				
				float4 transform = v.vertex;
				
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);

				o.vertex = UnityObjectToClipPos(transform);
				
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
		    float3 position = i.vertexInWorldCoords.xyz;
		    float3 vIncident = normalize(position - _WorldSpaceCameraPos);
			
			   
		    	 //taken from exaple code for edge 
		     float2 texel = float2(
            _MainTex_TexelSize.x * 1, 
            _MainTex_TexelSize.y * 1
           );
		    
		    
		    float tx1y0 = tex2D( _MainTex, i.uv + texel * float2( -1, 0 ) ).r ;;
		    float tx2y0 = tex2D( _MainTex, i.uv + texel * float2( 1, 0 ) ).r ;;
		    
		    
        float tx0y1 = tex2D( _MainTex, i.uv + texel * float2( 0,  1 ) ).r ;
        float tx0y2 = tex2D( _MainTex, i.uv + texel * float2( 0,  -1 ) ).r ;
		      
		  float3 normal = -cross(normalize(float3(-1, tx1y0, 0)), normalize(float3(0, tx0y1, 1)));
		  
		  //float3 normal = float3(tx1y0 - tx2y0, 1/4, tx0y1 - tx0y2);
		  
			
		    float3 vReflect = reflect(vIncident, i.normalInWorldCoords);//cross(i.normalInWorldCoords, normal));
					/*If Roughness feature is not needed : UNITY_SAMPLE_TEXCUBE(unity_SpecCube0, reflection) can be used instead.
					It chooses the correct LOD value based on camera distance*/
            half4 skyData = UNITY_SAMPLE_TEXCUBE_LOD(_Cube, vReflect, _Roughness);
            //half3 skyColor = DecodeHDR (skyData, unity_SpecCube0_HDR); // This is done becasue the cubemap is stored HDR
            return half4(skyColor, 1.0);
	
		  }
			ENDCG
		}
	}

    Fallback "Diffuse"
}
